#include <iostream>

int main() {
    float matrix1[4][4] =   {{5.35, 2.57, 3.25, 4.547},
                             {1.945, 2.656, 3.56, 4.856},
                             {1.415, 2.265, 3.879, 4.48},
                             {1.98, 2.381, 3.816, 4.482}};
    for (int i = 0; i < 4; ++i) {
        for (int j = 0; j < 4; ++j) {
            if (i == j) {
                std::cout << matrix1[i][j] << " ";
            } else {
                std::cout << "  " << 0 << "   ";
            }
        }
        std::cout << std::endl;
    }



/*
    int matrix1[4][4] = {{5, 2, 3, 4},
                         {1, 2, 3, 4},
                         {1, 2, 3, 4},
                         {1, 2, 3, 4}};
    int matrix2[4][4] = {{1, 2, 3, 4},
                         {1, 2, 3, 4},
                         {1, 2, 3, 4},
                         {1, 2, 3, 4}};
    bool equal = true;
    for (int i = 0; i < 4; ++i) {
        for (int j = 0; j < 4; ++j) {
            if (matrix1[i][j] != matrix2[i][j]) {
                equal = false;
                break;
            }
        }
    }
    std::cout << (equal?"matrix1 == matrix2":"matrix1 != matrix2");
*/
/*    int matrix[5][5];
    int count = 0;

    for (int i = 0; i < 5; ++i) {
        if (i % 2 == 0) {
            for (int j = 0; j < 5; ++j) {
                matrix[i][j] = count;
                count++;
            }
        } else {
            for (int j = 4; j >= 0; --j) {
                matrix[i][j] = count;
                count++;
            }
        }
    }
    for (int i = 0; i < 5; ++i) {
        for (int j = 0; j < 5; ++j) {
            std::cout << matrix[i][j] << " ";
        }
        std::cout << std::endl;
    }
*/

/*
    bool cutlery[12][4] = {{true, true, true, false},
                           {true, true, true, false},
                           {true, true, true, false},
                           {true, true, true, false},
                           {true, true, true, false},
                           {true, true, true, true},
                           {true, true, true, true},
                           {true, true, true, false},
                           {true, true, true, false},
                           {true, true, true, false},
                           {true, true, true, false},
                           {true, true, true, false}};
    int crockery[12][2] = {{2, 0},
                           {2, 0},
                           {2, 0},
                           {2, 0},
                           {2, 0},
                           {2, 1},
                           {2, 1},
                           {2, 0},
                           {2, 0},
                           {2, 0},
                           {2, 0},
                           {2, 0}};
    int chairs[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

    chairs[5]++;
    cutlery[9][1] = false;
    cutlery[6][1] = false;
    cutlery[9][1] = true;
    crockery[6][1] = 0;


    for (int i = 0; i < 12; ++i) {
        for (int j = 0; j < 4; ++j) {
            std::cout << cutlery[i][j] << " ";
        }
        std::cout << std::endl;
    }

    for (int i = 0; i < 12; ++i) {
        for (int j = 0; j < 2; ++j) {
            std::cout << crockery[i][j] << " ";
        }
        std::cout << std::endl;
    }

    for (int i = 0; i < 12; ++i) {
        std::cout << chairs[i] << " ";

    }
    std::cout << std::endl;
*/

    return 0;
}
/*
 *
 * Задача 2. Крестики-нолики

Старинная-добрая игра на страницах всех школьных тетрадей. Поле размером 3х3 представлено в виде двумерного массива с
 типом элементов char. Помните тот символьный тип из предыдущего модуля? Теперь он нам и пригодится. Участвуют два
 игрока, которые ходят по очереди и ставят в указанные ими в стандартном вводе координаты свой символ - ‘X’ или ‘O’
 (буквы латинского алфавита). Как только у одного из игроков будет установлено подряд три крестика или три нолика - он
 побеждает. Если свободных клеток не осталось, а трёх совпадающих элементов не найдено - объявляется ничья. Для
 простоты, мы не будем рассматривать диагональные совпадения, а только строго вертикальные либо строго горизонтальные.

Изначально всё поле инициализируется символом пробела - ‘ ‘. Это можно сделать сразу при объявлении, либо с помощью
 вложенного цикла. На каждом ходе, при занятой клетке или при неверных координатах этой клетки должно быть выведено
 сообщение и игрок должен указать координаты клетки повторно. После каждого хода надо выводить в консоль текущее
 состояние всего игрового поля, для наглядности.

Сделаю ещё одну небольшую подсказку. Проверку на победу игрока, которую надо осуществлять после каждого хода, можно
 сделать с помощью вложенного цикла, сразу проверяя и вертикаль и горизонталь а как именно - попробуйте догадаться сами.
 *
 * Задача 1. Банкетный стол

По поводу успешного прохождения двумерных массивов собирается банкет, организуется стол на 12 персон, 2 из них - это
 места VIP, они расположены рядом друг к другу во главе стола. Стол протяжённый в длину, места расположены в два ряда.
 Каждый пришедший должен быть “упакован” соответствующим образом. Во-первых столовые приборы - их три на каждого
 человека (вилка, ложка, нож), плюс одна маленькая дополнительная ложечка для VIP-персон, для десерта. Это необходимо
 обеспечить. Следом тарелки, каждому по две - для первого и второго блюда, для VIP персон +1 тарелка для десерта. Ну и
 конечно стул - один для каждого, минимум! Заведите соответствующие двумерные массивы для количества приборов, посуды и
 стульев и проинициализируйте их как следует.

Однако, это ещё не всё. В ходе банкета, уже после инициализации, происходят некоторые события. Пришедшая на 5-ое место
 первого ряда дама пришла вместе с ребёнком и поэтому на данное место был приставлен ещё один стул. С третьего места во
 втором ряду в неизвестном направлении была украдена ложка. После этого одна из VIP персон (любая) поделилась своей
 ложкой с тем у кого она пропала, а сам стал есть суп десертной. За ненадобностью официант забрал у него одну десертную
 тарелку, ибо есть десерт ложкой, которая побывала уже в супе - не комильфо. Больше без происшествий!*/