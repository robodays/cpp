#include <iostream>
#include <string>
#include <vector>
//#include <cstdlib>

struct Personages {
    std::string name;
    int level;
    int armor;
    int damage;
    bool isHero = false;
    int positionXY[2] = {0,0};

//+ Каждый персонаж игры представлен в виде структуры с полями: имя, жизни, броня, урон.
//+ Советы и рекомендации
//+ Для определения команды персонажа можно завести специальный флаг внутри структуры данных персонажа.
//Для отображения координат персонажей можете использовать структуру вектора из другой задачи, но заменить типы координат.
};
const int X = 40;
const int Y = 40;

void CreateHero(Personages& hero);
void GeneratePositionPersonage(int positionXY[], int xMax = X, int yMax = Y);

void PrintGameField(std::vector<std::vector<char>> field);
void CreateGameField(std::vector<std::vector<char>> field, int xMax = X, int yMax = Y);


int main() {
    std::cout << "Turn-based role-playing game." << std::endl;
    std::vector<std::vector<char>> field(40,std::vector<char> (40,'.'));
    CreateGameField(field);
    PrintGameField(field);
    Personages hero;
    CreateHero(hero);
    return 0;
}

void CreateHero(Personages& hero) {
//Игрок конструирует своего персонажа самостоятельно. Задаёт все его параметры, включая имя.
    hero.isHero = true;
    std::cout << "Enter name hero: " << std::endl;
    std::cin >> hero.name;
    std::cout << "Enter level hero: " << std::endl;
    std::cin >> hero.level;
    std::cout << "Enter armor hero: " << std::endl;
    std::cin >> hero.armor;
    std::cout << "Enter damage hero: " << std::endl;
    std::cin >> hero.damage;
    //GeneratePositionPersonage(hero.positionXY);
}

void CreateEnemy() {
//Вначале игры создаются 5 случайных врагов в случайных клетках карты. Имена врагам задаются в формате “Enemy #N”,
// где N — это порядковый номер врага. Уровень жизней врагам задаётся случайно, от 50 до 150. Уровень брони варьируется
// от 0 до 50. Урон тоже выбирается случайно от 15 до 30 единиц.
}

void CreateGameField(std::vector<std::vector<char>> field, int xMax, int yMax) {
// Игра происходит на карте размером 40 на 40 клеток.
    for (int i = 0; i < 40; i++) {
        for (int j = 0; j < 40; ++j) {
            field[i][j] = '.';
        }
    }
}

void PrintGameField(std::vector<std::vector<char>> field) {
// Игра происходит на карте размером 40 на 40 клеток.
    for (int i = 0; i < 40; i++) {
        for (int j = 0; j < 40; ++j) {
            std::cout << field[i][j];
        }
        std::cout << std::endl;
    }
}

void GeneratePositionPersonage(int positionXY[], int xMax, int yMax) {
    //Все персонажи появляются в случайных местах карты.


}

void PrintPersonages() {
// После каждого хода игрока карта показывается вновь со всеми врагами на ней. Игрок помечается буквой P. Враги буквой E.
// Пустые места — точкой.
}

void MovingOnField() {
// По клеткам перемещаются враги и персонаж игрока.
//Игрок осуществляет ход с помощью команд: left, right, top, bottom. В зависимости от команды и выбирается направление
// перемещения персонажа: влево, вправо, вверх, вниз.
}

void CheckingMoving() {
// За пределы карты (40 на 40 клеток) ходить нельзя никому. Если кто-то выбрал направление за гранью дозволенного, ход
// пропускается.
}

void GenerateMovingForEnemy() {
// Враги перемещаются в случайном направлении.
}

void Attack() {
// Если персонаж (враг или игрок) перемещается в сторону, где уже находится какой-то персонаж, то он бьёт этого персонажа
// с помощью своего урона. Враги при этом никогда не бьют врагов, а просто пропускают ход и остаются на своём месте.

// Формула для расчёта урона совпадает с той, что была в самом уроке. Жизни уменьшаются на оставшийся после брони урон.
// При этом сама броня тоже сокращается на приведённый урон.
}

void CheckingEndgame() {
// Игра заканчивается тогда, когда либо умирают все враги, либо персонаж игрока. В первом случае на экран выводится
// сообщение о поражении, во втором — победа.
}

void SaveGame() {
// Если в начале хода игрок вводит команду save или load вместо направления перемещения, то игра либо делает сохранение
// своего состояния в файл, либо загружает это состояние из файла соответственно.
}

void LoadGame () {
// Если в начале хода игрок вводит команду save или load вместо направления перемещения, то игра либо делает сохранение
// своего состояния в файл, либо загружает это состояние из файла соответственно.

}


/*
Задание 4. Реализация ролевой пошаговой игры


Что нужно сделать

Реализуйте сильно упрощённую версию ролевой пошаговой игры:

Игра происходит на карте размером 40 на 40 клеток. По клеткам перемещаются враги и персонаж игрока.

После каждого хода игрока карта показывается вновь со всеми врагами на ней. Игрок помечается буквой P. Враги буквой E.
 Пустые места — точкой.

Каждый персонаж игры представлен в виде структуры с полями: имя, жизни, броня, урон.

Вначале игры создаются 5 случайных врагов в случайных клетках карты. Имена врагам задаются в формате “Enemy #N”,
 где N — это порядковый номер врага. Уровень жизней врагам задаётся случайно, от 50 до 150. Уровень брони варьируется
 от 0 до 50. Урон тоже выбирается случайно от 15 до 30 единиц.

Игрок конструирует своего персонажа самостоятельно. Задаёт все его параметры, включая имя.

Все персонажи появляются в случайных местах карты.

Игрок осуществляет ход с помощью команд: left, right, top, bottom. В зависимости от команды и выбирается направление
 перемещения персонажа: влево, вправо, вверх, вниз.

Враги перемещаются в случайном направлении.

Если персонаж (враг или игрок) перемещается в сторону, где уже находится какой-то персонаж, то он бьёт этого персонажа
 с помощью своего урона. Враги при этом никогда не бьют врагов, а просто пропускают ход и остаются на своём месте.

 За пределы карты (40 на 40 клеток) ходить нельзя никому. Если кто-то выбрал направление за гранью дозволенного, ход
 пропускается.

Формула для расчёта урона совпадает с той, что была в самом уроке. Жизни уменьшаются на оставшийся после брони урон.
 При этом сама броня тоже сокращается на приведённый урон.

Игра заканчивается тогда, когда либо умирают все враги, либо персонаж игрока. В первом случае на экран выводится
 сообщение о поражении, во втором — победа.

Если в начале хода игрок вводит команду save или load вместо направления перемещения, то игра либо делает сохранение
 своего состояния в файл, либо загружает это состояние из файла соответственно.



Советы и рекомендации

Для определения команды персонажа можно завести специальный флаг внутри структуры данных персонажа.

Для отображения координат персонажей можете использовать структуру вектора из другой задачи, но заменить типы координат.



Что оценивается

Корректность работы игры.



Как отправить задание на проверку

Пришлите ссылку на repl.it или файл .срр с решением через форму для сдачи домашнего задания.
 */